<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ballerburg Science: Mobile & Responsive</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #2c3e50;
            color: white;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            /* Verhindert "Pull-to-refresh" auf Mobile beim Spielen */
            overscroll-behavior: none; 
        }

        h1 {
            text-align: center;
            margin: 0 0 10px 0;
            font-size: clamp(1.2rem, 4vw, 2rem); /* Schriftgr√∂√üe passt sich an */
        }

        /* HAUPT CONTAINER */
        #main-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            gap: 15px;
        }

        /* OBEN: SPIEL BEREICH */
        #game-section {
            position: relative;
            width: 100%;
            /* Verh√§ltnis 2:1 erzwingen (Breite:H√∂he) */
            aspect-ratio: 2 / 1; 
            border: 2px solid #34495e;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        canvas#gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none; /* WICHTIG: Verhindert Scrollen beim Zielen */
        }

        /* UNTEN: DASHBOARD BEREICH */
        #dashboard-section {
            display: flex;
            flex-wrap: wrap; /* Umbruch auf kleinen Screens */
            gap: 10px;
            width: 100%;
        }

        .panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            border: 1px solid #555;
            display: flex;
            flex-direction: column;
        }

        /* Linkes Panel: Chart */
        #chart-panel {
            flex: 2; /* Nimmt mehr Platz auf Desktop */
            min-width: 300px; /* Mindestbreite bevor Umbruch */
            height: 250px;
            position: relative;
        }

        /* Rechtes Panel: Daten */
        #data-panel {
            flex: 1;
            min-width: 250px;
            height: 250px;
        }

        canvas#chartCanvas {
            width: 100%;
            height: 100%;
            background: #ecf0f1;
            border-radius: 4px;
        }

        /* LOG / TABELLE */
        .data-header {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;
        }
        
        button {
            background: #27ae60; border: none; color: white; padding: 8px 12px;
            cursor: pointer; border-radius: 4px; font-weight: bold; font-size: 14px;
        }
        /* Gr√∂√üere Buttons f√ºr Touch */
        button:active { transform: scale(0.95); }

        #log-container {
            flex-grow: 1;
            overflow-y: auto;
            background: rgba(255,255,255,0.1);
            font-family: monospace;
            font-size: 12px;
            padding: 5px;
            -webkit-overflow-scrolling: touch; /* Weiches Scrollen auf iOS */
        }

        .log-entry { 
            margin-bottom: 4px; padding-bottom: 4px;
            border-bottom: 1px solid #555; 
            display: flex; justify-content: space-between; 
        }

        /* IN-GAME UI OVERLAY */
        #ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 10px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-top {
            display: flex; justify-content: space-between; align-items: flex-start;
            width: 100%;
        }

        .hud-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 12px; border-radius: 20px; font-weight: bold; font-size: 14px;
            pointer-events: auto; display: flex; align-items: center; gap: 8px; color: white;
            backdrop-filter: blur(2px);
        }

        .status-msg {
            position: absolute; top: 20%; width: 100%; text-align: center;
            font-size: clamp(1.5rem, 5vw, 2.5rem); font-weight: 900; 
            text-shadow: 2px 2px 0 black, -1px -1px 0 black;
            pointer-events: none;
        }

        /* Checkbox gr√∂√üer f√ºr Finger */
        input[type="checkbox"] { transform: scale(1.3); margin-right: 5px; }

    </style>
</head>
<body>

    <h1>üè∞ Physik Labor: Wurfparabel</h1>

    <div id="main-container">
        
        <div id="game-section">
            <canvas id="gameCanvas" width="1000" height="500"></canvas>
            
            <div id="ui-overlay">
                <div class="hud-top">
                    <div class="hud-box">
                        <input type="checkbox" id="windCheck"> <label for="windCheck">Wind</label>
                    </div>
                    <div class="hud-box">
                        <input type="checkbox" id="wallCheck" checked> <label for="wallCheck">Mauer</label>
                    </div>
                    <div class="hud-box">
                        <input type="checkbox" id="previewCheck"> <label for="previewCheck">Vorschau</label>
                    </div>
                    <div class="hud-box">
                        <span id="windDisplay">Wind: 0</span>
                    </div>
                </div>
                
                <div class="status-msg" id="statusText">Lade Spiel...</div>

                <div id="controls-area" style="display:flex; justify-content: center; align-items: center; gap: 10px; pointer-events: auto; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 10px; flex-wrap: wrap;">
                    <div style="display:flex; flex-direction:column; align-items:center;">
                        <label style="font-size:12px; margin-bottom:2px;">Winkel</label>
                        <input type="number" id="inputAngle" value="45" min="0" max="90" style="width:60px; padding:5px; border-radius:4px; border:none; text-align:center; color:black;">
                    </div>
                    <div style="display:flex; flex-direction:column; align-items:center;">
                        <label style="font-size:12px; margin-bottom:2px;">v0 (m/s)</label>
                        <input type="number" id="inputPower" value="15" min="0" max="100" style="width:60px; padding:5px; border-radius:4px; border:none; text-align:center; color:black;">
                    </div>
                    <div style="display:flex; flex-direction:column; align-items:center;">
                        <label style="font-size:12px; margin-bottom:2px;">Gravitation</label>
                        <input type="range" id="inputGravity" value="9.81" min="0" max="25" step="0.1" style="width:80px; cursor:pointer;">
                        <span id="gravityDisplay" style="font-size:10px;">9.81 m/s¬≤</span>
                    </div>
                    <button id="btnFire" style="background:#c0392b; padding: 10px 20px; font-size: 16px; border: 2px solid white;">FEUER</button>
                    <button id="reset-btn" style="background:#e67e22; margin-left: 5px;">‚Ü∫</button>
                </div>
            </div>
        </div>

        <div id="dashboard-section">
            <div id="chart-panel" class="panel">
                <div style="position:absolute; top:5px; left:10px; color:#2c3e50; font-weight:bold; font-size:12px;">
                    Streudiagramm: Winkel (X) vs. Weite (Y)
                </div>
                <canvas id="chartCanvas" width="600" height="250"></canvas>
            </div>

            <div id="data-panel" class="panel">
                <div class="data-header">
                    <strong>Wertetabelle</strong>
                    <button onclick="exportCSV()" style="padding:4px 8px; font-size:12px;">üíæ CSV</button>
                </div>
                <div id="log-container">Warte auf ersten Schuss...</div>
            </div>
        </div>
    </div>

<script>
window.addEventListener('load', function() {
    // --- SETUP ---
    const gameCanvas = document.getElementById('gameCanvas');
    const ctx = gameCanvas.getContext('2d');
    const chartCanvas = document.getElementById('chartCanvas');
    const ctxChart = chartCanvas.getContext('2d');

    // UI Refs
    const uiStatus = document.getElementById('statusText');
    const uiWind = document.getElementById('windDisplay');
    const uiLog = document.getElementById('log-container');
    const checkWind = document.getElementById('windCheck');
    const checkWall = document.getElementById('wallCheck');
    const checkPreview = document.getElementById('previewCheck');
    const btnReset = document.getElementById('reset-btn');
    const btnFire = document.getElementById('btnFire');
    const inputAngle = document.getElementById('inputAngle');
    const inputPower = document.getElementById('inputPower');
    const inputGravity = document.getElementById('inputGravity');
    const gravityDisplay = document.getElementById('gravityDisplay');

    // Konstanten
    const GROUND_Y = 450;
    const PIXELS_PER_METER = 40; // Ma√üstab: 40px = 1m
    const FPS = 60;
    const MAX_DRAG_DIST = 250;

    // State
    let shotHistory = [];
    let game = {
        gravity: 0.25,
        turn: 1,
        wind: 0,
        windEnabled: false,
        wallEnabled: true,
        previewEnabled: false,
        isAnimating: false,
        isAiming: false,
        aimVector: { x: 0, y: 0, power: 0, angle: 0 },
        ball: null,
        particles: [],
        players: [],
        obstacle: { x: 450, y: GROUND_Y - 150, w: 100, h: 150, color: '#7f8c8d' },
        trajectoryPoints: []
    };

    function init() {
        game.players = [
            { id: 1, x: 50, y: GROUND_Y - 60, w: 60, h: 60, hp: 200, color: '#3498db', name: "BLAU" },
            { id: 2, x: 890, y: GROUND_Y - 60, w: 60, h: 60, hp: 200, color: '#e74c3c', name: "ROT" }
        ];
        game.ball = null;
        game.particles = [];
        game.isAnimating = false;
        game.turn = 1;
        
        if(game.windEnabled) randomizeWind(); else game.wind = 0;
        game.isAiming = true;
        updateUI();
        updateGravity();
        updateAimFromInputs();
        drawChart();
        requestAnimationFrame(loop);
    }

    // --- GAME LOOP ---
    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    function update() {
        if (game.ball) {
            game.ball.vy += game.gravity;
            game.ball.vx += game.wind * PIXELS_PER_METER / (FPS * FPS);
            game.ball.x += game.ball.vx;
            game.ball.y += game.ball.vy;

            let hit = false;
            let finalX = game.ball.x; // Trefferposition speichern
            
            // Kollisionspr√ºfungen
            if (game.ball.y >= GROUND_Y) { createExplosion(game.ball.x, GROUND_Y, "#27ae60"); hit = true; }
            else if (game.wallEnabled && checkRectCollide(game.ball.x, game.ball.y, game.obstacle)) { createExplosion(game.ball.x, game.ball.y, game.obstacle.color); hit = true; }
            else if (game.ball.x < -100 || game.ball.x > gameCanvas.width + 100) { hit = true; }
            else {
                let enemy = game.players[game.turn === 1 ? 1 : 0];
                if (checkRectCollide(game.ball.x, game.ball.y, enemy)) {
                    // Kinetische Energie berechnen: E = 0.5 * m * v^2 (m=1kg)
                    let v_px = Math.sqrt(game.ball.vx * game.ball.vx + game.ball.vy * game.ball.vy);
                    let v_ms = v_px * (FPS / PIXELS_PER_METER);
                    let damage = 0.5 * v_ms * v_ms;
                    enemy.hp -= damage;
                    createExplosion(game.ball.x, game.ball.y, enemy.color);
                    hit = true;
                    if (enemy.hp <= 0) setTimeout(() => { alert(game.players[game.turn-1].name + " GEWINNT!"); init(); shotHistory=[]; uiLog.innerHTML=""; drawChart(); }, 100);
                }
            }

            if (hit) {
                recordShot(finalX);
                endTurn();
            }
        }
        // Partikel
        for (let i = game.particles.length - 1; i >= 0; i--) {
            let p = game.particles[i];
            p.life--; p.x += p.vx; p.y += p.vy;
            if (p.life <= 0) game.particles.splice(i, 1);
        }
    }

    function draw() {
        // Clear
        const grad = ctx.createLinearGradient(0, 0, 0, 500);
        grad.addColorStop(0, "#87CEEB"); grad.addColorStop(1, "#E0F6FF");
        ctx.fillStyle = grad; ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

        // Objekte
        if (game.wallEnabled) {
            ctx.fillStyle = game.obstacle.color; ctx.fillRect(game.obstacle.x, game.obstacle.y, game.obstacle.w, game.obstacle.h);
        }
        ctx.fillStyle = "#27ae60"; ctx.fillRect(0, GROUND_Y, gameCanvas.width, gameCanvas.height - GROUND_Y);

        game.players.forEach(p => {
            if (p.hp > 0) {
                ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.w, p.h);
                // HP Bar
                ctx.fillStyle = "black"; ctx.fillRect(p.x, p.y - 20, p.w, 6);
                ctx.fillStyle = (p.hp>100) ? "#2ecc71" : "#e74c3c"; ctx.fillRect(p.x+1, p.y - 19, (p.w-2) * (p.hp/200), 4);
            }
        });

        // Aiming
        if (game.isAiming && !game.isAnimating) {
            drawAimLine();
            if (game.previewEnabled) {
                drawTrajectory();
            }
        }

        // Ball
        if (game.ball) {
            ctx.fillStyle = "#2c3e50"; ctx.beginPath(); ctx.arc(game.ball.x, game.ball.y, 6, 0, Math.PI*2); ctx.fill();
        }
        
        // Partikel
        game.particles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill(); });
    }

    // --- DATA RECORDER ---
    function recordShot(finalX) {
        let activeP = game.players[game.turn - 1];
        let startX = activeP.x + activeP.w/2;
        let distance = Math.abs(finalX - startX);
        let angle = Math.round(game.aimVector.angle);
        // if (game.turn === 2) angle = 180 - angle; // Nicht mehr n√∂tig bei direkter Eingabe
        // angle = Math.abs(angle);
        let speed = parseFloat(inputPower.value);
        let distMeters = (distance / PIXELS_PER_METER).toFixed(2);

        let dataPoint = {
            id: shotHistory.length + 1,
            player: activeP.name.charAt(0), // B oder R
            color: activeP.color,
            angle: angle,
            power: speed,
            distance: parseFloat(distMeters)
        };
        shotHistory.push(dataPoint);
        
        // Log Update
        let row = document.createElement('div');
        row.className = 'log-entry';
        row.style.borderLeft = `4px solid ${dataPoint.color}`;
        row.style.paddingLeft = "5px";
        row.innerHTML = `<span>#${dataPoint.id}</span> <span>${dataPoint.angle}¬∞</span> <span>${dataPoint.power} m/s</span> <span>-> ${dataPoint.distance} m</span>`;
        if(uiLog.innerHTML.includes("Warte")) uiLog.innerHTML = "";
        uiLog.prepend(row);
        
        drawChart();
    }

    // --- CHART ---
    function drawChart() {
        const w = chartCanvas.width;
        const h = chartCanvas.height;
        // High DPI Support f√ºr Chart
        chartCanvas.width = chartCanvas.clientWidth * 2;
        chartCanvas.height = chartCanvas.clientHeight * 2;
        ctxChart.scale(2, 2);
        
        // Reset scale for drawing
        const dw = chartCanvas.clientWidth;
        const dh = chartCanvas.clientHeight;
        
        ctxChart.clearRect(0,0,dw,dh);
        const pad = 30;

        // Grid
        ctxChart.strokeStyle = "#95a5a6"; ctxChart.lineWidth = 1; ctxChart.beginPath();
        ctxChart.moveTo(pad, pad); ctxChart.lineTo(pad, dh-pad); // Y
        ctxChart.moveTo(pad, dh-pad); ctxChart.lineTo(dw-pad, dh-pad); // X
        ctxChart.stroke();

        ctxChart.fillStyle = "#34495e"; ctxChart.font = "10px sans-serif";
        ctxChart.fillText("Weite (m)", 2, pad-5); ctxChart.fillText("Winkel (¬∞)", dw-50, dh-5);

        for(let deg=0; deg<=90; deg+=15) {
            let x = pad + (deg/90)*(dw-2*pad);
            ctxChart.fillText(deg, x-5, dh-10);
            ctxChart.fillRect(x, dh-pad-2, 1, 4);
        }

        if (shotHistory.length === 0) return;
        let maxDist = Math.max(...shotHistory.map(s => s.distance), 25); // Min 25m Scale

        shotHistory.forEach(s => {
            let px = pad + (s.angle / 90) * (dw - 2*pad);
            let py = (dh - pad) - (s.distance / maxDist) * (dh - 2*pad);
            ctxChart.fillStyle = s.color; ctxChart.beginPath(); ctxChart.arc(px, py, 5, 0, Math.PI*2); ctxChart.fill();
            ctxChart.strokeStyle = "#fff"; ctxChart.stroke();
        });
    }


    // --- UNIFIED INPUT HANDLER (TOUCH & MOUSE) ---
    // Dies ist der Schl√ºssel f√ºr Mobile!
    
    function updateAimFromInputs() {
        if (game.isAnimating) return;
        
        let angle = parseFloat(inputAngle.value);
        let speedMS = parseFloat(inputPower.value); // Jetzt m/s
        
        // Clamp values
        if (angle < 0) angle = 0; if (angle > 90) angle = 90;
        if (speedMS < 0) speedMS = 0; if (speedMS > 100) speedMS = 100;

        // Umrechnung m/s in Pixel/Frame
        // v_px = v_ms * PIXELS_PER_METER / FPS
        let speedPxPerFrame = speedMS * PIXELS_PER_METER / FPS;

        let rad = angle * (Math.PI / 180);
        
        let dx = Math.cos(rad) * speedPxPerFrame;
        let dy = -Math.sin(rad) * speedPxPerFrame;
        
        if (game.turn === 2) {
            dx = -dx;
        }
        
        // Power f√ºr Visualisierung (Pfeill√§nge)
        let visualPower = Math.min((speedMS / 30) * MAX_DRAG_DIST, MAX_DRAG_DIST);
        game.aimVector = { x: dx, y: dy, power: visualPower, angle: angle };
        calculateTrajectory();
    }

    function calculateTrajectory() {
        game.trajectoryPoints = [];
        const activeP = game.players[game.turn - 1];
        let simX = activeP.x + activeP.w / 2;
        let simY = activeP.y + activeP.h / 2;
        let simVX = game.aimVector.x; // Ist jetzt schon korrekt skaliert
        let simVY = game.aimVector.y;

        for (let i = 0; i < 150; i++) {
            simVY += game.gravity; simVX += game.wind * PIXELS_PER_METER / (FPS * FPS);
            simX += simVX; simY += simVY;
            if (i % 4 === 0) game.trajectoryPoints.push({x: simX, y: simY});
            if (simY >= GROUND_Y || (game.wallEnabled && checkRectCollide(simX, simY, game.obstacle))) break;
        }
    }

    function fire() {
        if (game.isAnimating) return;
        const activeP = game.players[game.turn - 1];
        game.ball = {
            x: activeP.x + activeP.w / 2, y: activeP.y + activeP.h / 2,
            vx: game.aimVector.x, vy: game.aimVector.y
        };
        game.isAnimating = true;
        game.isAiming = false;
        uiStatus.innerText = "";
    }

    function updateGravity() {
        let val = parseFloat(inputGravity.value);
        gravityDisplay.innerText = val.toFixed(2) + " m/s¬≤";
        // g_px = g_ms * PIXELS_PER_METER / FPS^2
        game.gravity = val * PIXELS_PER_METER / (FPS * FPS);
        if(game.isAiming) calculateTrajectory();
    }

    // --- EVENT LISTENERS (Unified) ---
    inputAngle.addEventListener('input', updateAimFromInputs);
    inputPower.addEventListener('input', updateAimFromInputs);
    inputGravity.addEventListener('input', updateGravity);
    btnFire.addEventListener('click', fire);

    // --- HELPER ---
    function drawAimLine() {
        const activeP = game.players[game.turn - 1];
        const cx = activeP.x + activeP.w / 2; const cy = activeP.y + activeP.h / 2;
        
        // Visualisierung berechnen (Winkel + VisualPower)
        let len = game.aimVector.power;
        let rad = game.aimVector.angle * (Math.PI / 180);
        let dx = Math.cos(rad) * len;
        let dy = -Math.sin(rad) * len;
        if (game.turn === 2) dx = -dx;

        let intensity = Math.min(1, len / MAX_DRAG_DIST); 
        ctx.strokeStyle = `rgb(${255},${Math.floor(255*(1-intensity))},0)`;
        ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + dx, cy + dy); ctx.stroke();

        // Pfeilspitze
        let headLen = 15; let angleVec = Math.atan2(dy, dx);
        ctx.beginPath(); ctx.moveTo(cx + dx, cy + dy); ctx.lineTo(cx + dx - headLen * Math.cos(angleVec - Math.PI/6), cy + dy - headLen * Math.sin(angleVec - Math.PI/6)); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx + dx, cy + dy); ctx.lineTo(cx + dx - headLen * Math.cos(angleVec + Math.PI/6), cy + dy - headLen * Math.sin(angleVec + Math.PI/6)); ctx.stroke();
    }
    function drawTrajectory() { ctx.fillStyle = "rgba(255, 255, 255, 0.5)"; game.trajectoryPoints.forEach(pt => { ctx.beginPath(); ctx.arc(pt.x, pt.y, 4, 0, Math.PI*2); ctx.fill(); }); }
    function createExplosion(x, y, color) { for (let i = 0; i < 20; i++) game.particles.push({x:x,y:y,vx:(Math.random()-0.5)*10,vy:(Math.random()-0.5)*10,life:30+Math.random()*20,r:Math.random()*5,color:color}); }
    function checkRectCollide(bx, by, rect) { return bx > rect.x && bx < rect.x + rect.w && by > rect.y && by < rect.y + rect.h; }
    function endTurn() { 
        game.ball = null; 
        game.isAnimating = false; 
        game.turn = game.turn === 1 ? 2 : 1; 
        if(game.windEnabled) randomizeWind(); else game.wind=0; 
        updateUI(); 
        game.isAiming = true;
        updateAimFromInputs();
    }
    function randomizeWind() { game.wind = (Math.random() * 10) - 5; } // -5 bis 5 m/s¬≤
    function updateUI() { 
        uiStatus.innerText = game.players[game.turn-1].name + " ZIELT"; 
        uiStatus.style.color = game.players[game.turn-1].color;
        let dir = game.wind > 0 ? "‚Üí" : (Math.abs(game.wind)<0.1?"‚Ä¢":"‚Üê"); 
        uiWind.innerText = `Wind: ${dir} ${Math.abs(game.wind).toFixed(2)} m/s¬≤`;
    }
    
    // CSV Export
    window.exportCSV = function() {
        if(shotHistory.length === 0) { alert("Keine Daten."); return; }
        let csvContent = "data:text/csv;charset=utf-8,ID;Spieler;Winkel;Kraft;Distanz\n";
        shotHistory.forEach(r => { csvContent += `${r.id};${r.player};${r.angle};${r.power};${r.distance}\n`; });
        let encodedUri = encodeURI(csvContent);
        let link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "ballerburg_data.csv");
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    };

    checkWind.addEventListener('change', (e) => { game.windEnabled = e.target.checked; if(!game.windEnabled) game.wind = 0; updateUI(); });
    checkWall.addEventListener('change', (e) => { game.wallEnabled = e.target.checked; });
    checkPreview.addEventListener('change', (e) => { game.previewEnabled = e.target.checked; });
    btnReset.addEventListener('click', init);

    init();
});
</script>
</body>
</html>